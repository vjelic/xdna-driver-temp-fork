{
  "version": "2.1.0",
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Glog.AI",
          "organization": "Glog.AI",
          "fullName": "Glog, Making software more secure",
          "version": "1.0.0",
          "semanticVersion": "1.0.0",
          "informationUri": "https://www.glog.ai",
          "rules": [
            {
              "id": "glog-346396f5-780b-4b2d-9765-cf147aff1010",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function: `memcpy`\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows. This can occur if the destination buffer is not large enough to hold the data being copied, or if the size of the data being copied is not correctly calculated. This vulnerability can lead to undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to accommodate the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` from the C++ Standard Library, which provide better safety guarantees.\n3. **Boundary Checks**: Implement boundary checks to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability sink:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assuming buf->args and sn->prop_args are properly defined and initialized\n// and arg_sz is the size of the data to be copied\n\n// Ensure that the destination buffer is large enough\nsize_t dest_size = sizeof(buf->args); // Replace with actual size of buf->args\nsize_t copy_size = std::min(arg_sz, dest_size);\n\nmemcpy(buf->args, sn->prop_args, copy_size);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-4fedc579-a4a5-4b5d-b9a9-b01cbf00f44e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming, which can lead to buffer overflow issues if not properly handled. The specific line of code:\n\n```cpp\nmemcpy(buf->args, payload, payload_len);\n```\n\nis vulnerable because it does not ensure that the destination buffer `buf->args` is large enough to hold the data being copied from `payload`. If `payload_len` exceeds the size of `buf->args`, it can result in a buffer overflow, potentially leading to undefined behavior, data corruption, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to accommodate the data being copied. This can be done by checking the size of the destination buffer before performing the copy operation.\n\n2. **Use Safer Functions**: Consider using safer alternatives to `memcpy`, such as `memmove` or `strncpy`, which provide additional safety checks.\n\n3. **Input Validation**: Validate all inputs to ensure they are within expected ranges and sizes before processing them.\n\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflow vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the size of the destination buffer is checked before performing the copy operation. Here is a revised version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n\n// Assume buf->args_size is the size of the buffer\nif (payload_len <= buf->args_size) {\n    memcpy(buf->args, payload, payload_len);\n} else {\n    // Handle error: payload is too large for the buffer\n    // This could involve logging the error, returning an error code, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-467aaf0c-bbf8-46d8-a817-36dd628b5a58",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++, which is used to copy a block of memory from one location to another. The specific issue here is that the size of the data being copied (`sizeof(req.dpu_pmpt.payload)`) may not match the size of the source data (`pd->prop_args`). This can lead to buffer overflows if the source data is larger than the destination buffer, potentially causing undefined behavior, data corruption, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the size of the data being copied does not exceed the size of the destination buffer.\n2. **Use Safer Functions**: Consider using safer alternatives like `std::copy` or `std::memmove` which provide better safety guarantees.\n3. **Static Analysis**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the size of the data being copied does not exceed the size of the destination buffer. Here is a revised version of the code:\n\n```cpp\n#include <cstring> // Required for std::memcpy\n#include <algorithm> // Required for std::min\n\n// Assuming req.dpu_pmpt.payload and pd->prop_args are properly defined\nsize_t payload_size = sizeof(req.dpu_pmpt.payload);\nsize_t prop_args_size = /* size of pd->prop_args */; // Define the size of pd->prop_args\n\n// Ensure we do not copy more than the destination can hold\nsize_t copy_size = std::min(payload_size, prop_args_size);\nstd::memcpy(req.dpu_pmpt.payload, pd->prop_args, copy_size);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For `std::memcpy`.\n- `<algorithm>`: For `std::min`.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-388f7a3e-036c-43bd-b22f-fb72d8c60f68",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming, which can lead to buffer overflow if not used carefully. The specific line of code:\n\n```cpp\nmemcpy(req.dpu.payload, sn->prop_args, sizeof(req.dpu.payload));\n```\n\nsuggests that data is being copied from `sn->prop_args` to `req.dpu.payload` without ensuring that the source data fits within the destination buffer. If `sn->prop_args` is larger than `req.dpu.payload`, this can result in a buffer overflow, potentially leading to undefined behavior, data corruption, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the size of the source data does not exceed the size of the destination buffer.\n2. **Use Safer Functions**: Consider using safer alternatives like `memmove` or `strncpy` that include bounds checking.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows.\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the size of the data being copied does not exceed the size of the destination buffer. Here is a revised version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n\n// Assuming sn->prop_args is a null-terminated string or has a known size\nsize_t prop_args_size = strlen(sn->prop_args); // or use a known size if available\nsize_t payload_size = sizeof(req.dpu.payload);\n\nif (prop_args_size < payload_size) {\n    memcpy(req.dpu.payload, sn->prop_args, prop_args_size);\n} else {\n    // Handle error: source data is too large for the destination buffer\n    // For example, truncate or log an error\n    memcpy(req.dpu.payload, sn->prop_args, payload_size - 1);\n    req.dpu.payload[payload_size - 1] = '\\0'; // Null-terminate if necessary\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependency is required:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-b6f00106-87f4-4604-8920-1fdf09f7984c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++, which can lead to buffer overflow if not used carefully. The function call `memcpy(req.ebuf.payload, payload, sizeof(req.ebuf.payload))` copies data from `payload` to `req.ebuf.payload`. If the size of `payload` exceeds the size of `req.ebuf.payload`, it can result in a buffer overflow, potentially leading to undefined behavior, data corruption, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the source data does not exceed the destination buffer size.\n2. **Use Safer Functions**: Consider using safer alternatives like `memmove` or `strncpy` that provide additional safety checks.\n3. **Input Validation**: Validate all inputs to ensure they are within expected ranges and sizes.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows during development.\n5. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow, ensure that the size of the data being copied does not exceed the size of the destination buffer. Here is a revised version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n\n// Assuming payload_size is the actual size of the data in payload\nsize_t payload_size = /* actual size of payload */;\nif (payload_size <= sizeof(req.ebuf.payload)) {\n    memcpy(req.ebuf.payload, payload, payload_size);\n} else {\n    // Handle error: payload is too large\n    // e.g., log an error, truncate data, or return an error code\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a394686f-049f-41eb-8465-5dadeb91fe3e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-5e2cbc69-fbe3-4240-bbe6-08478a84f0c6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-f2487bb7-7f4d-411c-9bdc-7d3fab0cbfa2",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++. The `memcpy` function is used to copy a block of memory from one location to another. The issue arises when the destination buffer is not large enough to hold the data being copied, leading to a buffer overflow. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\nIn the provided code snippet, the `memcpy` function is used as follows:\n\n```cpp\nmemcpy(cu_conf_param_buf.data() + sizeof(amdxdna_ccmd_config_ctx_req),\n    arg.conf_buf.data(), arg.conf_buf.size());\n```\n\nThe vulnerability occurs if `cu_conf_param_buf` does not have enough space to accommodate the data being copied from `arg.conf_buf`. This can lead to overwriting adjacent memory, causing potential security risks.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer before performing the copy operation.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` which provide better safety guarantees and are less prone to errors.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is large enough to hold the data being copied. Here is a revised version of the code with bounds checking:\n\n```cpp\n#include <algorithm> // for std::min\n#include <cstring>   // for std::memcpy\n\n// Ensure cu_conf_param_buf is large enough\nif (cu_conf_param_buf.size() >= sizeof(amdxdna_ccmd_config_ctx_req) + arg.conf_buf.size()) {\n    std::memcpy(cu_conf_param_buf.data() + sizeof(amdxdna_ccmd_config_ctx_req),\n                arg.conf_buf.data(), arg.conf_buf.size());\n} else {\n    // Handle error: destination buffer is not large enough\n    // This could involve logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<algorithm>`: For `std::min` (if used for additional safety checks).\n- `<cstring>`: For `std::memcpy`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-419c3509-138b-4587-a978-4b15a278ee95",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `memcpy` function in C++ arises from its potential to cause buffer overflows if the destination buffer is not large enough to accommodate the data being copied. This can lead to undefined behavior, including data corruption, crashes, and security vulnerabilities such as arbitrary code execution. The specific issue with the call `memcpy(out_buf, m_resp_buf->get(), sz)` is that it does not verify whether `out_buf` has sufficient space to hold `sz` bytes of data from `m_resp_buf->get()`. If `sz` exceeds the size of `out_buf`, a buffer overflow will occur.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` which provide better safety guarantees and are easier to use correctly.\n\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential security issues early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the size of `out_buf` is checked before performing the `memcpy` operation. Here is a revised version of the code:\n\n```cpp\n#include <cstring> // For std::memcpy\n#include <algorithm> // For std::min\n\n// Assuming out_buf_size is the size of out_buf\nsize_t out_buf_size = /* size of out_buf */;\n\n// Ensure that we do not copy more than the size of out_buf\nsize_t copy_size = std::min(sz, out_buf_size);\n\nstd::memcpy(out_buf, m_resp_buf->get(), copy_size);\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library headers are required:\n\n- `<cstring>`: Provides the `std::memcpy` function.\n- `<algorithm>`: Provides the `std::min` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5ed20689-0e73-4691-b48b-e4b47b751b47",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-865de33e-4526-4855-aa6e-a53182886e74",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Vulnerable/Compromised Hash Algorithm\" vulnerability in C++ refers to the use of cryptographic hash functions that are considered weak or broken, such as MD2. MD2 is an older hash function that is no longer considered secure due to its susceptibility to collision attacks, where two different inputs produce the same hash output. This vulnerability can lead to security issues such as data integrity violations and unauthorized data access.\n\n### General Mitigation Advice\n\n1. **Avoid Using Weak Hash Functions**: Replace MD2 with a more secure hash function like SHA-256 or SHA-3.\n2. **Use Well-Maintained Libraries**: Utilize cryptographic libraries that are actively maintained and updated.\n3. **Regularly Update Dependencies**: Ensure that all cryptographic libraries are up-to-date to benefit from the latest security patches.\n\n### Source Code Fix Recommendation\n\nBelow is an example of how to replace MD2 with SHA-256 using the OpenSSL library in C++.\n\n```cpp\n#include <openssl/sha.h>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <string>\n\n// Function to compute SHA-256 hash\nstd::string computeSHA256(const std::string& data) {\n    unsigned char hash[SHA256_DIGEST_LENGTH];\n    SHA256_CTX sha256;\n    SHA256_Init(&sha256);\n    SHA256_Update(&sha256, data.c_str(), data.size());\n    SHA256_Final(hash, &sha256);\n\n    std::stringstream ss;\n    for (int i = 0; i < SHA256_DIGEST_LENGTH; ++i) {\n        ss << std::hex << std::setw(2) << std::setfill('0') << (int)hash[i];\n    }\n    return ss.str();\n}\n\nint main() {\n    std::string data = \"example data\";\n    std::string hash = computeSHA256(data);\n    std::cout << \"SHA-256 hash: \" << hash << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code, you need the following library:\n\n- OpenSSL\n\nEnsure that OpenSSL is installed on your system and linked during compilation. You can compile the code using:\n\n```bash\ng++ -o hash_example hash_example.cpp -lssl -lcrypto\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Cryptographic Storage Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-327: Use of a Broken or Risky Cryptographic Algorithm](https://cwe.mitre.org/data/definitions/327.html)"
              },
              "properties": {
                "tags": [
                  "DS126858"
                ]
              }
            },
            {
              "id": "glog-2aad7c9b-e97c-49d7-a8f9-3d44868a8439",
              "help": {
                "text": "",
                "markdown": "### Detected Issue with C Function: memcpy\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming, which can lead to buffer overflow if not properly managed. The specific line of code:\n\n```cpp\nmemcpy((u8 *)kern_buf, (u8 *)(sys_buf + head_ptr_wrap), log_size);\n```\n\nThis line copies `log_size` bytes from `sys_buf + head_ptr_wrap` to `kern_buf`. If `log_size` is larger than the destination buffer `kern_buf` can hold, it will result in a buffer overflow, potentially leading to undefined behavior, data corruption, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer against `log_size`.\n\n2. **Use Safer Functions**: Consider using safer alternatives like `memmove` or `strncpy` if applicable, which provide additional safety checks.\n\n3. **Input Validation**: Validate all inputs to ensure they are within expected ranges before performing operations.\n\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow, ensure that the size of `kern_buf` is checked before performing the `memcpy` operation. Here is a revised version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n\n// Assume kern_buf_size is the size of kern_buf\nsize_t kern_buf_size = /* size of kern_buf */;\n\nif (log_size <= kern_buf_size) {\n    memcpy((u8 *)kern_buf, (u8 *)(sys_buf + head_ptr_wrap), log_size);\n} else {\n    // Handle error: log_size is too large for kern_buf\n    // This could involve logging an error, truncating the data, or other appropriate action\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0284202c-f6cc-4a2d-a043-643e6a374dcc",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflow vulnerabilities, which occur when the destination buffer is not large enough to hold the data being copied. This can result in memory corruption, crashes, or even arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((u8 *)(kern_buf + part_log), (u8 *)sys_buf, tail_ptr_wrap);\n```\n\nThe vulnerability may occur if `kern_buf + part_log` does not have enough space to accommodate `tail_ptr_wrap` bytes. This can lead to writing beyond the allocated memory for `kern_buf`, causing undefined behavior.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` if overlapping memory regions are involved, or higher-level abstractions that automatically manage buffer sizes.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the destination buffer has enough space before performing the copy operation. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <cstddef> // Required for size_t\n\n// Assume these are defined and initialized appropriately\nu8* kern_buf;\nu8* sys_buf;\nsize_t part_log;\nsize_t tail_ptr_wrap;\nsize_t kern_buf_size; // Size of kern_buf\n\nif (part_log + tail_ptr_wrap <= kern_buf_size) {\n    memcpy((u8 *)(kern_buf + part_log), (u8 *)sys_buf, tail_ptr_wrap);\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<cstddef>`: For the `size_t` type.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-eb0ff63c-cb4e-4377-8c1a-7465d298a99e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming, which can lead to buffer overflow issues if not properly managed. The specific line of code:\n\n```cpp\nmemcpy((u8 *)kern_buf, (u8 *)(sys_buf + head_ptr_wrap), part_log);\n```\n\nindicates a potential risk where the source buffer (`sys_buf + head_ptr_wrap`) and the destination buffer (`kern_buf`) may not be adequately sized to handle the number of bytes specified by `part_log`. This can result in memory corruption, crashes, or even arbitrary code execution if an attacker can influence the size or content of the data being copied.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to accommodate the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Functions**: Consider using safer alternatives like `memmove` or `strncpy` if applicable, which provide additional safety checks.\n\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow in the given code, ensure that the size of the destination buffer is checked against the size of the data being copied. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n\n// Assume these are defined and initialized appropriately\nu8 *kern_buf;\nu8 *sys_buf;\nsize_t head_ptr_wrap;\nsize_t part_log;\nsize_t kern_buf_size; // Size of the destination buffer\n\nif (part_log <= kern_buf_size) {\n    memcpy((u8 *)kern_buf, (u8 *)(sys_buf + head_ptr_wrap), part_log);\n} else {\n    // Handle error: part_log exceeds the size of kern_buf\n    // This could be logging the error, returning an error code, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is necessary for using the `memcpy` function.\n\n### OWASP Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f81ae598-f7dc-4022-9bc2-f17c69551237",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming. The `memcpy` function is used to copy a block of memory from one location to another. However, if not used carefully, it can lead to buffer overflow vulnerabilities, which occur when the destination buffer is not large enough to hold the data being copied. This can result in memory corruption, crashes, or even arbitrary code execution.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy((u8 *)(kern_buf + part_log), (u8 *)sys_buf, tail_ptr_wrap);\n```\n\nThe vulnerability may occur if `kern_buf + part_log` does not have enough space to accommodate `tail_ptr_wrap` bytes. This can lead to writing beyond the allocated memory for `kern_buf`, causing undefined behavior.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by performing explicit bounds checking before calling `memcpy`.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` if overlapping memory regions are involved, or higher-level abstractions that automatically manage buffer sizes.\n\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the destination buffer has enough space before performing the copy operation. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <cstddef> // Required for size_t\n\n// Assume these are defined and initialized appropriately\nu8* kern_buf;\nu8* sys_buf;\nsize_t part_log;\nsize_t tail_ptr_wrap;\nsize_t kern_buf_size; // Size of kern_buf\n\nif (part_log + tail_ptr_wrap <= kern_buf_size) {\n    memcpy((u8 *)(kern_buf + part_log), (u8 *)sys_buf, tail_ptr_wrap);\n} else {\n    // Handle error: destination buffer is not large enough\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<cstddef>`: For the `size_t` type.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-a60bf3cc-d8b1-49b3-accd-b3e844a23282",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++, which can lead to buffer overflow issues if not properly managed. The specific line of code:\n\n```cpp\nmemcpy((u8 *)kern_buf, (u8 *)sys_buf + tail_ptr_wrap, part_log);\n```\n\nindicates that data is being copied from `sys_buf` to `kern_buf`. If `part_log` exceeds the size of `kern_buf`, it can result in a buffer overflow, potentially leading to undefined behavior, data corruption, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer against the size of the data being copied.\n\n2. **Use Safer Functions**: Consider using safer alternatives like `memmove` or `std::copy` from the C++ Standard Library, which provide better safety guarantees.\n\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the size of `kern_buf` is checked before performing the `memcpy` operation. Here is a revised version of the code with added bounds checking:\n\n```cpp\n#include <cstring> // Required for memcpy\n\n// Assuming kern_buf_size is the size of kern_buf\nif (part_log <= kern_buf_size) {\n    memcpy((u8 *)kern_buf, (u8 *)sys_buf + tail_ptr_wrap, part_log);\n} else {\n    // Handle error: part_log exceeds the size of kern_buf\n    // This could be logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [Common Weakness Enumeration: CWE-120](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-e58532b1-90d0-4ff7-9cde-8297aaf4399c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy(m_log_buf, &m_metadata, sizeof(m_metadata))` can lead to a buffer overflow if `m_log_buf` is not large enough to hold the data being copied from `m_metadata`. This can result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `std::copy` or `std::memmove` which provide better safety guarantees.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that `m_log_buf` is properly sized before performing the `memcpy` operation. Here is a revised version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n\n// Assuming m_log_buf and m_metadata are defined elsewhere\n// Ensure m_log_buf is large enough\nif (sizeof(m_log_buf) >= sizeof(m_metadata)) {\n    memcpy(m_log_buf, &m_metadata, sizeof(m_metadata));\n} else {\n    // Handle error: buffer is not large enough\n    // This could be logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependency is required:\n\n- `<cstring>`: This header is required for the `memcpy` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-ad3b405a-ca2e-453e-9319-881fa4143c5c",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `memcpy` function in C++ often arises from improper handling of memory, particularly when the source and destination buffers overlap or when the destination buffer is not large enough to accommodate the data being copied. This can lead to buffer overflows, data corruption, or undefined behavior, which are critical security issues.\n\nIn the provided code snippet:\n\n```cpp\nmemcpy(pdi_vaddr, pdi.data(), pdi.size());\n```\n\nThe potential issues include:\n\n- **Buffer Overflow**: If `pdi_vaddr` does not have enough allocated memory to hold `pdi.size()` bytes, this will result in a buffer overflow.\n- **Undefined Behavior**: If `pdi_vaddr` and `pdi.data()` overlap, the behavior of `memcpy` is undefined.\n\n### General Mitigation Advice\n\n1. **Ensure Sufficient Buffer Size**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `std::copy` or `std::memmove` if there is a possibility of overlapping memory regions.\n3. **Bounds Checking**: Implement rigorous bounds checking before performing memory operations.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory issues.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the destination buffer is adequately sized and consider using `std::copy` for safer memory operations:\n\n```cpp\n#include <algorithm> // for std::copy\n#include <vector>\n\n// Assuming pdi is a std::vector or similar container\nstd::vector<char> pdi; // Example initialization\nchar* pdi_vaddr = new char[pdi.size()]; // Ensure sufficient size\n\n// Use std::copy for safer memory copying\nstd::copy(pdi.begin(), pdi.end(), pdi_vaddr);\n\n// Clean up if necessary\ndelete[] pdi_vaddr;\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library headers are required:\n\n- `<algorithm>`: For `std::copy`.\n- `<vector>`: If using `std::vector` for the `pdi` container.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-77f1cec0-f210-4f76-9e89-bf0057125cee",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-c33143c6-df85-446d-8d9e-7bdc696a9806",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-e8eb877a-517a-41f9-b352-3429a722831c",
              "help": {
                "text": "",
                "markdown": "## Description\n\nThe \"Prohibited C Function Identified\" vulnerability in C++ programming language refers to the use of certain C standard library functions that are known to be dangerous due to their potential to cause buffer overflow, leading to arbitrary code execution, denial of service, or information disclosure. One such function is `sprintf`.\n\nThe `sprintf` function is used to write formatted data to a string. However, it does not check the size of the destination buffer, which can lead to buffer overflow if the source data is larger than the destination buffer.\n\n## Mitigation Advice\n\nTo mitigate this vulnerability, use safer alternatives that check the size of the destination buffer. In the case of `sprintf`, a safer alternative is `snprintf`, which takes an additional parameter specifying the size of the destination buffer.\n\n## Source Code Fix Recommendation\n\nReplace `sprintf` with `snprintf` as shown below:\n\n```cpp\n// Vulnerable code\nchar buffer[50];\nsprintf(buffer, \"%s\", some_large_string);\n\n// Fixed code\nchar buffer[50];\nsnprintf(buffer, sizeof(buffer), \"%s\", some_large_string);\n```\n\n## Library Dependencies\n\nThe code example requires the C standard library (`<cstdio>` or `<stdio.h>` in C++).\n\n## References\n\n- [OWASP C++ Secure Coding Practices](https://cheatsheetseries.owasp.org/cheatsheets/C-Based_Toolchain_Hardening_Cheat_Sheet.html)"
              },
              "properties": {
                "tags": [
                  "DS154189"
                ]
              }
            },
            {
              "id": "glog-669eb18f-5271-4501-ab14-72188cd20441",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming, which can lead to buffer overflow if not properly handled. The specific line of code:\n\n```cpp\nmemcpy(psp->fw_buffer + offset, conf->fw_buf, conf->fw_size);\n```\n\nis vulnerable because it does not ensure that the destination buffer (`psp->fw_buffer`) has enough space to accommodate the data being copied from the source buffer (`conf->fw_buf`). If `conf->fw_size` is larger than the available space in `psp->fw_buffer` starting from `offset`, it can lead to memory corruption, crashes, or potential security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by checking the size of the destination buffer against the size of the data to be copied.\n\n2. **Use Safer Functions**: Consider using safer alternatives like `memmove` or `std::copy` in C++ which provide better safety guarantees.\n\n3. **Input Validation**: Validate all inputs to ensure they are within expected ranges and sizes before performing operations on them.\n\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer has enough space before performing the copy operation. Here is a revised version of the code with added checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n\n// Assuming psp and conf are properly defined and initialized\nif (offset + conf->fw_size <= sizeof(psp->fw_buffer)) {\n    memcpy(psp->fw_buffer + offset, conf->fw_buf, conf->fw_size);\n} else {\n    // Handle error: buffer overflow risk\n    // Log an error, throw an exception, or handle the error appropriately\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0904a6bb-a601-42af-a866-2c7883a1b0d9",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++, which can lead to buffer overflow issues if not used carefully. The function call `memcpy(psp->psp_regs, conf->psp_regs, sizeof(psp->psp_regs))` copies data from `conf->psp_regs` to `psp->psp_regs`. If the source buffer (`conf->psp_regs`) is larger than the destination buffer (`psp->psp_regs`), this can result in a buffer overflow, potentially leading to undefined behavior, data corruption, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Always ensure that the source buffer is not larger than the destination buffer before performing the copy operation.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` or `std::copy` (for C++), which provide better safety checks.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows in your code.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo mitigate the risk of buffer overflow, ensure that the size of the data being copied does not exceed the size of the destination buffer. Here is a revised version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n\n// Assuming psp_regs is a fixed-size array\nconst size_t PSP_REGS_SIZE = sizeof(psp->psp_regs);\n\nif (sizeof(conf->psp_regs) <= PSP_REGS_SIZE) {\n    memcpy(psp->psp_regs, conf->psp_regs, sizeof(conf->psp_regs));\n} else {\n    // Handle error: source buffer is larger than destination buffer\n    // This could involve logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependency is required:\n\n- `<cstring>`: This header is required for the `memcpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-58676fef-2f89-4114-add4-ed2cd92d80e5",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C/C++ arises from its behavior of calculating the length of a string by searching for the null terminator (`'\\0'`). If the input string is not properly null-terminated or if the pointer passed to `strlen` is invalid, it can lead to undefined behavior, including buffer overflows, memory corruption, or crashes. This is particularly dangerous when dealing with user-controlled input or when the string is not properly validated.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is properly null-terminated before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions like `strnlen` which allows specifying a maximum length to prevent reading beyond the buffer.\n3. **Memory Management**: Ensure that memory is properly allocated and initialized before use.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nFor the specific vulnerability sink `strlen(\"resume\")`, ensure that the string is properly null-terminated and consider using `strnlen` to specify a maximum length:\n\n```cpp\n#include <cstring>\n#include <iostream>\n\nint main() {\n    const char* str = \"resume\";\n    // Use strnlen to specify a maximum length\n    size_t length = strnlen(str, 100); // Assuming 100 is the maximum expected length\n    std::cout << \"Length of the string is: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following standard library dependencies are required:\n\n- `<cstring>`: For string handling functions like `strlen` and `strnlen`.\n- `<iostream>`: For input and output stream operations.\n\n### Relevant Links\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nThese links were verified to be active and accessible for anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-cb969754-66d0-4ee1-8289-9ac7d8028596",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++. The function call `memcpy(data->m_clock_freq, clocks.data(), (clocks.size()` is incomplete and potentially dangerous. The issue is that the size parameter for `memcpy` is not properly specified, which can lead to buffer overflows if the destination buffer is not large enough to hold the data being copied. This can result in undefined behavior, including memory corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Ensure Proper Size Calculation**: Always ensure that the size parameter in `memcpy` accurately reflects the number of bytes to be copied. This should be the minimum of the source data size and the destination buffer size.\n2. **Use Safer Alternatives**: Consider using safer alternatives like `std::copy` or `std::memmove` which provide better type safety and can handle overlapping memory regions.\n3. **Bounds Checking**: Implement bounds checking to ensure that the destination buffer is large enough to accommodate the data being copied.\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n### Source Code Fix Recommendation\n\n```cpp\n#include <vector>\n#include <algorithm> // for std::copy\n\nstruct Data {\n    char* m_clock_freq;\n    size_t m_clock_freq_size; // Ensure this is properly initialized\n};\n\nvoid safeCopy(Data* data, const std::vector<char>& clocks) {\n    // Ensure the destination buffer is large enough\n    size_t bytesToCopy = std::min(data->m_clock_freq_size, clocks.size());\n    std::copy(clocks.data(), clocks.data() + bytesToCopy, data->m_clock_freq);\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard libraries are required:\n\n- `<vector>`: For using `std::vector`.\n- `<algorithm>`: For using `std::copy`.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-787: Out-of-bounds Write](https://cwe.mitre.org/data/definitions/787.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-5b76936a-58aa-4767-b5f3-d3bd3b5c5043",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises from its inability to handle null-terminated strings safely. If `strlen` is used on a string that is not properly null-terminated, it can lead to undefined behavior, including buffer overflows and memory corruption. This is particularly dangerous when the input to `strlen` is not validated or comes from an untrusted source.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Always validate input to ensure it is a properly null-terminated string before passing it to `strlen`.\n2. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that provide bounds checking, such as `std::string` in C++.\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential vulnerabilities related to string handling.\n4. **Code Reviews**: Regularly conduct code reviews to identify and mitigate potential vulnerabilities.\n\n### Source Code Fix Recommendation\n\nFor the specific vulnerability sink `strlen(\"suspend\")`, ensure that the string is properly null-terminated and consider using `std::string` for safer handling:\n\n```cpp\n#include <iostream>\n#include <string>\n\nint main() {\n    std::string str = \"suspend\";\n    std::cout << \"Length of string: \" << str.length() << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the above code example, the following library dependencies are required:\n\n- `<iostream>`: For input and output stream operations.\n- `<string>`: For using the `std::string` class.\n\n### Relevant Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-134: Use of Externally-Controlled Format String](https://cwe.mitre.org/data/definitions/134.html)\n\nThese links have been verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-4cdba605-8915-4e31-9acc-51fc99e127fe",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Use of Prohibited C Function (strcpy)\" vulnerability arises when the `strcpy` function is used in C++ programming. This function does not perform bounds checking on the destination buffer, which can lead to buffer overflow vulnerabilities. Buffer overflows can be exploited by attackers to execute arbitrary code, cause a program crash, or corrupt data.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or C++ string handling functions that perform bounds checking.\n2. **Input Validation**: Always validate input data to ensure it does not exceed buffer sizes.\n3. **Buffer Size Management**: Ensure that destination buffers are adequately sized to handle the maximum expected input size plus a null terminator.\n4. **Code Review and Testing**: Regularly review code for unsafe functions and test for buffer overflow vulnerabilities.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strcpy` with `strncpy` to prevent buffer overflow. Ensure that the destination buffer is large enough to hold the source string and a null terminator.\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Assuming h_clock.m_name is a character array with a known size\nconst size_t BUFFER_SIZE = sizeof(h_clock.m_name);\n\n// Use strncpy to safely copy the string\nstrncpy(h_clock.m_name, reinterpret_cast<const char*>(clock_metadata.h_clock.name), BUFFER_SIZE - 1);\n\n// Ensure null termination\nh_clock.m_name[BUFFER_SIZE - 1] = '\\0';\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using `strncpy`.\n\n### Relevant Resources\n\n- [OWASP Buffer Overflow](https://owasp.org/www-community/vulnerabilities/Buffer_Overflow)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-e543b0d8-26ae-4159-b497-24547c384302",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C++ arises when the function is used improperly, leading to potential buffer overflows or incorrect memory access. The `strlen` function calculates the length of a C-style string by searching for the null terminator (`'\\0'`). If the input to `strlen` is not properly null-terminated or if it points to an invalid memory location, it can cause undefined behavior, including reading beyond the buffer's bounds.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all strings passed to `strlen` are properly null-terminated.\n2. **Buffer Size Checks**: Always verify that buffers are large enough to hold the expected data plus the null terminator.\n3. **Use Safer Alternatives**: Consider using safer string handling functions or libraries that automatically manage buffer sizes and null-termination, such as `std::string` in C++.\n\n### Source Code Fix Recommendation\n\nFor the specific vulnerability sink `strlen(\"off\")`, ensure that the string is properly null-terminated and that the buffer is correctly sized. In this case, `\"off\"` is a string literal and is inherently null-terminated, so the direct use of `strlen` is safe. However, if the string were dynamically allocated or manipulated, additional checks would be necessary.\n\n```cpp\n#include <iostream>\n#include <cstring> // Required for strlen\n\nint main() {\n    const char* str = \"off\";\n    size_t length = strlen(str); // Safe usage as \"off\" is a string literal\n    std::cout << \"Length of string: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\n- `<iostream>`: Required for input and output operations.\n- `<cstring>`: Required for using the `strlen` function.\n\n### Relevant Resources\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n\nThese links are verified to be active and accessible to anonymous users."
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-a6342fa8-cc35-49b6-9b81-34e2ec5ca7e7",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability \"Detected Use of Prohibited C Function (strcpy)\" in C++ arises from the use of the `strcpy` function, which does not perform bounds checking on the destination buffer. This can lead to buffer overflow vulnerabilities if the source string is larger than the destination buffer, potentially allowing attackers to overwrite memory and execute arbitrary code.\n\n### General Mitigation Advice\n\n1. **Use Safer Alternatives**: Replace `strcpy` with safer alternatives like `strncpy`, `strlcpy`, or C++ string handling functions that perform bounds checking.\n2. **Input Validation**: Ensure that all input data is validated and sanitized before use.\n3. **Buffer Size Management**: Always ensure that destination buffers are large enough to hold the source data, including the null terminator.\n4. **Static Analysis Tools**: Use static analysis tools to detect unsafe function usage in the codebase.\n\n### Source Code Fix Recommendation\n\nReplace the use of `strcpy` with `strncpy` to ensure that the destination buffer is not overflowed. Here is the fixed code:\n\n```cpp\n#include <cstring> // Required for strncpy\n\n// Assuming mp_npu_clock.m_name is a char array with a defined size\nconst size_t BUFFER_SIZE = sizeof(mp_npu_clock.m_name);\nstrncpy(mp_npu_clock.m_name, reinterpret_cast<const char*>(clock_metadata.mp_npu_clock.name), BUFFER_SIZE - 1);\nmp_npu_clock.m_name[BUFFER_SIZE - 1] = '\\0'; // Ensure null-termination\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for using the `strncpy` function.\n\n### Relevant Resources\n\n- [OWASP Secure Coding Practices - Quick Reference Guide](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS185832"
                ]
              }
            },
            {
              "id": "glog-6850c250-82ce-4a65-8929-b35ea8c28021",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability associated with the `strlen` function in C/C++ arises when it is used improperly, leading to potential buffer overflows or incorrect memory access. The `strlen` function calculates the length of a string by searching for the null terminator (`'\\0'`). If the input to `strlen` is not properly null-terminated or if it points to an invalid memory location, it can cause undefined behavior, including reading beyond the buffer's bounds.\n\n### General Mitigation Advice\n\n1. **Input Validation**: Ensure that all strings passed to `strlen` are properly null-terminated.\n2. **Buffer Management**: Use safer string handling functions that limit the number of characters processed, such as `strnlen`.\n3. **Static Analysis**: Employ static analysis tools to detect potential buffer overflows and improper memory access.\n4. **Code Review**: Regularly review code to identify and fix improper use of string functions.\n\n### Source Code Fix Recommendation\n\nTo mitigate the specific vulnerability sink `strlen(\"on\")`, ensure that the input is properly null-terminated and consider using `strnlen` to limit the length of the string being processed.\n\n```cpp\n#include <cstring>\n#include <iostream>\n\nint main() {\n    const char* str = \"on\";\n    // Use strnlen to limit the length to a maximum expected size\n    size_t length = strnlen(str, 3); // Assuming the maximum expected length is 3\n    std::cout << \"Length of string: \" << length << std::endl;\n    return 0;\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following standard library dependencies are required:\n\n- `<cstring>`: For `strlen` and `strnlen` functions.\n- `<iostream>`: For input and output operations.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)\n- [CWE-126: Buffer Over-read](https://cwe.mitre.org/data/definitions/126.html)"
              },
              "properties": {
                "tags": [
                  "DS140021"
                ]
              }
            },
            {
              "id": "glog-775bfa79-b80b-4074-aa93-56cf383929fa",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe \"Detected Issue with C Function (memcpy)\" vulnerability in C++ arises when the `memcpy` function is used improperly, potentially leading to buffer overflows, memory corruption, or undefined behavior. This typically occurs when the size of the data being copied exceeds the size of the destination buffer, or when the source and destination overlap. In the provided code snippet, `memcpy(&mb->res, res, sizeof(*res))`, the vulnerability may occur if the size of `*res` is larger than the allocated space for `mb->res`.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Alternatives**: Consider using safer functions like `memmove` if there is a possibility of overlapping memory regions.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other memory issues.\n4. **Boundary Checks**: Implement boundary checks to ensure that the size of the data being copied does not exceed the size of the destination buffer.\n\n### Source Code Fix Recommendation\n\nTo mitigate the vulnerability, ensure that the destination buffer is adequately sized and consider using safer functions. Here's a revised version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n\n// Assuming mb->res is a buffer with a known size\nconst size_t RES_BUFFER_SIZE = /* size of mb->res */;\n\nif (sizeof(*res) <= RES_BUFFER_SIZE) {\n    memcpy(&mb->res, res, sizeof(*res));\n} else {\n    // Handle error: source size exceeds destination buffer\n    // e.g., log an error, throw an exception, etc.\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library is required:\n\n- `<cstring>`: This library is required for the `memcpy` function.\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-119: Improper Restriction of Operations within the Bounds of a Memory Buffer](https://cwe.mitre.org/data/definitions/119.html)\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-f91ab641-12af-4db9-baa5-4bf0ab5cc3e6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question involves the use of the `memcpy` function in C++, which is used to copy a block of memory from one location to another. The specific line of code:\n\n```cpp\nmemcpy(&mb_chann->res[CHAN_RES_I2X], i2x, sizeof(*i2x));\n```\n\nindicates a potential buffer overflow issue. This occurs when the destination buffer (`mb_chann->res[CHAN_RES_I2X]`) is not large enough to hold the data being copied from the source (`i2x`). If the size of the data pointed to by `i2x` exceeds the size of the destination buffer, it can lead to memory corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to accommodate the data being copied. This can be done by checking the size of the destination buffer before performing the copy operation.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives like `memmove` or `std::copy` from the C++ Standard Library, which provide better safety checks and are less prone to errors.\n\n3. **Boundary Checks**: Implement boundary checks to ensure that the data being copied does not exceed the size of the destination buffer.\n\n4. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflow vulnerabilities in the code.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the destination buffer is large enough to hold the data being copied. Here is a revised version of the code with boundary checks:\n\n```cpp\n#include <cstring> // Required for memcpy\n\n// Assuming mb_chann->res is an array and CHAN_RES_I2X is an index\n// Define the maximum size of the destination buffer\nconst size_t DEST_BUFFER_SIZE = /* appropriate size */;\n\nif (sizeof(*i2x) <= DEST_BUFFER_SIZE) {\n    memcpy(&mb_chann->res[CHAN_RES_I2X], i2x, sizeof(*i2x));\n} else {\n    // Handle error: data size exceeds buffer size\n    // Log an error, throw an exception, or take other appropriate action\n}\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following library dependencies are required:\n\n- `<cstring>`: This header is required for the `memcpy` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-c52064ef-d2e7-48f3-8f9c-5fef383af703",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++, which is used to copy a block of memory from one location to another. The specific issue here is that the size of the data being copied is determined by `sizeof(*x2i)`, which may not accurately reflect the intended size of the data to be copied. This can lead to buffer overflows if the destination buffer is not large enough to accommodate the data being copied, potentially resulting in undefined behavior, data corruption, or security vulnerabilities.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Ensure that the destination buffer is large enough to hold the data being copied. This can be done by comparing the size of the source data with the size of the destination buffer before performing the copy operation.\n\n2. **Use Safer Alternatives**: Consider using safer alternatives to `memcpy`, such as `std::copy` in C++ or `memmove`, which provide additional safety checks and are less prone to misuse.\n\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the size of the data being copied is correctly calculated and that the destination buffer is large enough to hold the data. Here's an example fix:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assuming mb_chann->res is a buffer with a known size\nconst size_t dest_size = sizeof(mb_chann->res) - CHAN_RES_X2I;\nconst size_t src_size = sizeof(*x2i); // Ensure this is the correct size\n\n// Use std::min to prevent buffer overflow\nmemcpy(&mb_chann->res[CHAN_RES_X2I], x2i, std::min(dest_size, src_size));\n```\n\n### Library Dependencies\n\nTo execute the code example properly, the following libraries are required:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-0272532d-5f4a-4bf1-82b8-2c6215035c9e",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C++, which is used to copy a block of memory from one location to another. The specific issue here is the potential for a buffer overflow or memory corruption if the size of the source data (`i2x`) is larger than the destination buffer (`record->re_i2x`). This can lead to undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied. This can be done by comparing the size of the source data with the size of the destination buffer.\n2. **Use Safer Functions**: Consider using safer alternatives like `std::copy` or `memmove` if overlapping memory regions are involved.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the size of the data being copied does not exceed the size of the destination buffer. Here is a revised version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assuming the size of re_i2x is known and defined as RE_I2X_SIZE\n#define RE_I2X_SIZE 256\n\nvoid safe_memcpy(Record* record, const I2X* i2x, size_t i2x_size) {\n    // Ensure we do not copy more than the destination can hold\n    size_t copy_size = std::min(i2x_size, sizeof(record->re_i2x));\n    memcpy(&record->re_i2x, i2x, copy_size);\n}\n```\n\n### Library Dependencies\n\nThe code example requires the following standard C++ libraries:\n\n- `<cstring>`: For the `memcpy` function.\n- `<algorithm>`: For the `std::min` function.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-7085d05b-0ea4-42f0-b60d-0a690e45dce6",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe vulnerability in question arises from the use of the `memcpy` function in C/C++ programming, which can lead to buffer overflow issues if not used carefully. The specific line of code:\n\n```cpp\nmemcpy(&record->re_x2i, x2i, sizeof(*x2i));\n```\n\nsuggests that data is being copied from `x2i` to `record->re_x2i`. If the size of the destination buffer `record->re_x2i` is smaller than the size of the data being copied, it can result in a buffer overflow, potentially leading to undefined behavior, data corruption, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Validate Buffer Sizes**: Always ensure that the destination buffer is large enough to hold the data being copied. Use safer alternatives like `memmove` or `strncpy` where appropriate, and always check buffer sizes before copying.\n\n2. **Use Safer Functions**: Consider using safer functions like `memcpy_s` if available, which include additional parameters for buffer size and can help prevent overflows.\n\n3. **Static Analysis Tools**: Utilize static analysis tools to detect potential buffer overflows and other vulnerabilities in your code.\n\n4. **Code Reviews**: Regularly conduct code reviews to catch potential vulnerabilities early in the development process.\n\n### Source Code Fix Recommendation\n\nTo fix the specific vulnerability, ensure that the destination buffer is large enough to accommodate the data being copied. Here is a revised version of the code:\n\n```cpp\n// Assuming record->re_x2i is a pointer to a buffer with known size\nsize_t destination_size = sizeof(record->re_x2i); // Replace with actual size of the buffer\nsize_t source_size = sizeof(*x2i);\n\nif (source_size <= destination_size) {\n    memcpy(&record->re_x2i, x2i, source_size);\n} else {\n    // Handle error: source data is too large for the destination buffer\n    // This could involve logging an error, throwing an exception, etc.\n}\n```\n\n### Library Dependencies\n\nThe code example provided primarily relies on standard C/C++ libraries. Ensure that the following headers are included:\n\n```cpp\n#include <cstring> // For memcpy\n```\n\n### Relevant OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            },
            {
              "id": "glog-721bb065-0c59-404e-8e37-48f76a76cb26",
              "help": {
                "text": "",
                "markdown": "### Description\n\nThe `memcpy` function in C/C++ is used to copy a specified number of bytes from a source memory location to a destination memory location. The vulnerability arises when the size of the data being copied (`msg->send_size`) exceeds the size of the destination buffer (`mb_msg->pkg.payload`). This can lead to buffer overflow, which may result in undefined behavior, including data corruption, crashes, or security vulnerabilities such as arbitrary code execution.\n\n### General Mitigation Advice\n\n1. **Bounds Checking**: Always ensure that the destination buffer is large enough to hold the data being copied.\n2. **Use Safer Functions**: Consider using safer alternatives like `memmove` or `strncpy` that provide additional safety checks.\n3. **Static Analysis Tools**: Use static analysis tools to detect potential buffer overflows.\n4. **Code Reviews**: Regularly perform code reviews to catch potential vulnerabilities early.\n\n### Source Code Fix Recommendation\n\nTo fix the vulnerability, ensure that the size of the data being copied does not exceed the size of the destination buffer. Here is a revised version of the code:\n\n```cpp\n#include <cstring> // Required for memcpy\n#include <algorithm> // Required for std::min\n\n// Assuming these are defined somewhere in the code\n#define PAYLOAD_SIZE 1024\n\nstruct Message {\n    char send_data[PAYLOAD_SIZE];\n    size_t send_size;\n};\n\nstruct Package {\n    char payload[PAYLOAD_SIZE];\n};\n\nstruct MBMessage {\n    Package pkg;\n};\n\nvoid safe_memcpy(MBMessage* mb_msg, const Message* msg) {\n    // Ensure that we do not copy more than the destination can hold\n    size_t copy_size = std::min(msg->send_size, sizeof(mb_msg->pkg.payload));\n    memcpy(mb_msg->pkg.payload, msg->send_data, copy_size);\n}\n```\n\n### Library Dependencies\n\n- `<cstring>`: Required for `memcpy`.\n- `<algorithm>`: Required for `std::min`.\n\n### OWASP Resources\n\n- [OWASP Top Ten](https://owasp.org/www-project-top-ten/)\n- [OWASP Secure Coding Practices](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)\n\n### Common Weakness Enumeration (CWE)\n\n- [CWE-120: Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')](https://cwe.mitre.org/data/definitions/120.html)"
              },
              "properties": {
                "tags": [
                  "DS121708"
                ]
              }
            }
          ],
          "language": "en-US",
          "contents": [
            "localizedData",
            "nonLocalizedData"
          ],
          "isComprehensive": false
        }
      },
      "language": "en-US",
      "results": [
        {
          "ruleId": "glog-346396f5-780b-4b2d-9765-cf147aff1010",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_message.c"
                },
                "region": {
                  "startLine": 863,
                  "startColumn": 1,
                  "endLine": 863,
                  "endColumn": 41,
                  "charOffset": 22109,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy(buf->args, sn->prop_args, arg_sz)",
                    "rendered": {
                      "text": "memcpy(buf->args, sn->prop_args, arg_sz)",
                      "markdown": "`memcpy(buf->args, sn->prop_args, arg_sz)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_message.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 22109,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf->args, <size of buf->args>,  sn->prop_args,  arg_sz)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4fedc579-a4a5-4b5d-b9a9-b01cbf00f44e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_message.c"
                },
                "region": {
                  "startLine": 827,
                  "startColumn": 1,
                  "endLine": 827,
                  "endColumn": 40,
                  "charOffset": 21159,
                  "charLength": 39,
                  "snippet": {
                    "text": "memcpy(buf->args, payload, payload_len)",
                    "rendered": {
                      "text": "memcpy(buf->args, payload, payload_len)",
                      "markdown": "`memcpy(buf->args, payload, payload_len)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_message.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 21159,
                        "charLength": 39
                      },
                      "insertedContent": {
                        "text": "memcpy_s(buf->args, <size of buf->args>,  payload,  payload_len)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-467aaf0c-bbf8-46d8-a817-36dd628b5a58",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_message.c"
                },
                "region": {
                  "startLine": 779,
                  "startColumn": 2,
                  "endLine": 779,
                  "endColumn": 74,
                  "charOffset": 20010,
                  "charLength": 72,
                  "snippet": {
                    "text": "memcpy(req.dpu_pmpt.payload, pd->prop_args, sizeof(req.dpu_pmpt.payload)",
                    "rendered": {
                      "text": "memcpy(req.dpu_pmpt.payload, pd->prop_args, sizeof(req.dpu_pmpt.payload)",
                      "markdown": "`memcpy(req.dpu_pmpt.payload, pd->prop_args, sizeof(req.dpu_pmpt.payload)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_message.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 20010,
                        "charLength": 72
                      },
                      "insertedContent": {
                        "text": "memcpy_s(req.dpu_pmpt.payload, <size of req.dpu_pmpt.payload>,  pd->prop_args,  sizeof(req.dpu_pmpt.payload)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-388f7a3e-036c-43bd-b22f-fb72d8c60f68",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_message.c"
                },
                "region": {
                  "startLine": 758,
                  "startColumn": 2,
                  "endLine": 758,
                  "endColumn": 64,
                  "charOffset": 19257,
                  "charLength": 62,
                  "snippet": {
                    "text": "memcpy(req.dpu.payload, sn->prop_args, sizeof(req.dpu.payload)",
                    "rendered": {
                      "text": "memcpy(req.dpu.payload, sn->prop_args, sizeof(req.dpu.payload)",
                      "markdown": "`memcpy(req.dpu.payload, sn->prop_args, sizeof(req.dpu.payload)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_message.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 19257,
                        "charLength": 62
                      },
                      "insertedContent": {
                        "text": "memcpy_s(req.dpu.payload, <size of req.dpu.payload>,  sn->prop_args,  sizeof(req.dpu.payload)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-b6f00106-87f4-4604-8920-1fdf09f7984c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_message.c"
                },
                "region": {
                  "startLine": 742,
                  "startColumn": 2,
                  "endLine": 742,
                  "endColumn": 60,
                  "charOffset": 18734,
                  "charLength": 58,
                  "snippet": {
                    "text": "memcpy(req.ebuf.payload, payload, sizeof(req.ebuf.payload)",
                    "rendered": {
                      "text": "memcpy(req.ebuf.payload, payload, sizeof(req.ebuf.payload)",
                      "markdown": "`memcpy(req.ebuf.payload, payload, sizeof(req.ebuf.payload)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_message.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18734,
                        "charLength": 58
                      },
                      "insertedContent": {
                        "text": "memcpy_s(req.ebuf.payload, <size of req.ebuf.payload>,  payload,  sizeof(req.ebuf.payload)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a394686f-049f-41eb-8465-5dadeb91fe3e",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/shim/host/platform_host.cpp"
                },
                "region": {
                  "startLine": 69,
                  "startColumn": 47,
                  "endLine": 69,
                  "endColumn": 50,
                  "charOffset": 2182,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/host/platform_host.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2182,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/host/platform_host.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2182,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-5e2cbc69-fbe3-4240-bbe6-08478a84f0c6",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/shim/host/platform_host.cpp"
                },
                "region": {
                  "startLine": 15,
                  "startColumn": 7,
                  "endLine": 15,
                  "endColumn": 10,
                  "charOffset": 313,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/host/platform_host.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 313,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/host/platform_host.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 313,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-f2487bb7-7f4d-411c-9bdc-7d3fab0cbfa2",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/shim/virtio/platform_virtio.cpp"
                },
                "region": {
                  "startLine": 442,
                  "startColumn": 7,
                  "endLine": 443,
                  "endColumn": 44,
                  "charOffset": 10864,
                  "charLength": 115,
                  "snippet": {
                    "text": "memcpy(cu_conf_param_buf.data() + sizeof(amdxdna_ccmd_config_ctx_req),\n    arg.conf_buf.data(), arg.conf_buf.size()",
                    "rendered": {
                      "text": "memcpy(cu_conf_param_buf.data() + sizeof(amdxdna_ccmd_config_ctx_req),\n    arg.conf_buf.data(), arg.conf_buf.size()",
                      "markdown": "`memcpy(cu_conf_param_buf.data() + sizeof(amdxdna_ccmd_config_ctx_req),\n    arg.conf_buf.data(), arg.conf_buf.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/virtio/platform_virtio.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 10864,
                        "charLength": 115
                      },
                      "insertedContent": {
                        "text": "memcpy_s(cu_conf_param_buf.data() + sizeof(amdxdna_ccmd_config_ctx_req), <size of cu_conf_param_buf.data() + sizeof(amdxdna_ccmd_config_ctx_req)>, \n    arg.conf_buf.data(),  arg.conf_buf.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-419c3509-138b-4587-a978-4b15a278ee95",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/shim/virtio/platform_virtio.cpp"
                },
                "region": {
                  "startLine": 318,
                  "startColumn": 4,
                  "endLine": 318,
                  "endColumn": 42,
                  "charOffset": 7707,
                  "charLength": 38,
                  "snippet": {
                    "text": "memcpy(out_buf, m_resp_buf->get(), sz)",
                    "rendered": {
                      "text": "memcpy(out_buf, m_resp_buf->get(), sz)",
                      "markdown": "`memcpy(out_buf, m_resp_buf->get(), sz)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/virtio/platform_virtio.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 7707,
                        "charLength": 38
                      },
                      "insertedContent": {
                        "text": "memcpy_s(out_buf, <size of out_buf>,  m_resp_buf->get(),  sz)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5ed20689-0e73-4691-b48b-e4b47b751b47",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/shim/virtio/platform_virtio.cpp"
                },
                "region": {
                  "startLine": 65,
                  "startColumn": 47,
                  "endLine": 65,
                  "endColumn": 50,
                  "charOffset": 1862,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/virtio/platform_virtio.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1862,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/virtio/platform_virtio.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1862,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-865de33e-4526-4855-aa6e-a53182886e74",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Weak/Broken Hash Algorithm"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/shim/virtio/platform_virtio.cpp"
                },
                "region": {
                  "startLine": 25,
                  "startColumn": 7,
                  "endLine": 25,
                  "endColumn": 10,
                  "charOffset": 541,
                  "charLength": 3,
                  "snippet": {
                    "text": "md2",
                    "rendered": {
                      "text": "md2",
                      "markdown": "`md2`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/virtio/platform_virtio.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 541,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha512"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "A weak or broken hash algorithm was detected."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/virtio/platform_virtio.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 541,
                        "charLength": 3
                      },
                      "insertedContent": {
                        "text": "sha256"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Critical",
            "DevSkimConfidence": "High",
            "tags": [
              "Cryptography.BannedHashAlgorithm"
            ]
          }
        },
        {
          "ruleId": "glog-2aad7c9b-e97c-49d7-a8f9-3d44868a8439",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_event_trace.c"
                },
                "region": {
                  "startLine": 100,
                  "startColumn": 1,
                  "endLine": 100,
                  "endColumn": 66,
                  "charOffset": 2954,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy((u8 *)kern_buf, (u8 *)(sys_buf + head_ptr_wrap), log_size)",
                    "rendered": {
                      "text": "memcpy((u8 *)kern_buf, (u8 *)(sys_buf + head_ptr_wrap), log_size)",
                      "markdown": "`memcpy((u8 *)kern_buf, (u8 *)(sys_buf + head_ptr_wrap), log_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_event_trace.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2954,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s((u8 *)kern_buf, <size of (u8 *)kern_buf>,  (u8 *)(sys_buf + head_ptr_wrap),  log_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0284202c-f6cc-4a2d-a043-643e6a374dcc",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_event_trace.c"
                },
                "region": {
                  "startLine": 96,
                  "startColumn": 2,
                  "endLine": 96,
                  "endColumn": 67,
                  "charOffset": 2801,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy((u8 *)(kern_buf + part_log), (u8 *)sys_buf, tail_ptr_wrap)",
                    "rendered": {
                      "text": "memcpy((u8 *)(kern_buf + part_log), (u8 *)sys_buf, tail_ptr_wrap)",
                      "markdown": "`memcpy((u8 *)(kern_buf + part_log), (u8 *)sys_buf, tail_ptr_wrap)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_event_trace.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2801,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s((u8 *)(kern_buf + part_log), <size of (u8 *)(kern_buf + part_log)>,  (u8 *)sys_buf,  tail_ptr_wrap)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-eb0ff63c-cb4e-4377-8c1a-7465d298a99e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_event_trace.c"
                },
                "region": {
                  "startLine": 95,
                  "startColumn": 2,
                  "endLine": 95,
                  "endColumn": 67,
                  "charOffset": 2732,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy((u8 *)kern_buf, (u8 *)(sys_buf + head_ptr_wrap), part_log)",
                    "rendered": {
                      "text": "memcpy((u8 *)kern_buf, (u8 *)(sys_buf + head_ptr_wrap), part_log)",
                      "markdown": "`memcpy((u8 *)kern_buf, (u8 *)(sys_buf + head_ptr_wrap), part_log)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_event_trace.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2732,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s((u8 *)kern_buf, <size of (u8 *)kern_buf>,  (u8 *)(sys_buf + head_ptr_wrap),  part_log)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f81ae598-f7dc-4022-9bc2-f17c69551237",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_event_trace.c"
                },
                "region": {
                  "startLine": 87,
                  "startColumn": 2,
                  "endLine": 87,
                  "endColumn": 67,
                  "charOffset": 2481,
                  "charLength": 65,
                  "snippet": {
                    "text": "memcpy((u8 *)(kern_buf + part_log), (u8 *)sys_buf, tail_ptr_wrap)",
                    "rendered": {
                      "text": "memcpy((u8 *)(kern_buf + part_log), (u8 *)sys_buf, tail_ptr_wrap)",
                      "markdown": "`memcpy((u8 *)(kern_buf + part_log), (u8 *)sys_buf, tail_ptr_wrap)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_event_trace.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2481,
                        "charLength": 65
                      },
                      "insertedContent": {
                        "text": "memcpy_s((u8 *)(kern_buf + part_log), <size of (u8 *)(kern_buf + part_log)>,  (u8 *)sys_buf,  tail_ptr_wrap)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a60bf3cc-d8b1-49b3-accd-b3e844a23282",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_event_trace.c"
                },
                "region": {
                  "startLine": 86,
                  "startColumn": 2,
                  "endLine": 86,
                  "endColumn": 65,
                  "charOffset": 2414,
                  "charLength": 63,
                  "snippet": {
                    "text": "memcpy((u8 *)kern_buf, (u8 *)sys_buf + tail_ptr_wrap, part_log)",
                    "rendered": {
                      "text": "memcpy((u8 *)kern_buf, (u8 *)sys_buf + tail_ptr_wrap, part_log)",
                      "markdown": "`memcpy((u8 *)kern_buf, (u8 *)sys_buf + tail_ptr_wrap, part_log)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_event_trace.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2414,
                        "charLength": 63
                      },
                      "insertedContent": {
                        "text": "memcpy_s((u8 *)kern_buf, <size of (u8 *)kern_buf>,  (u8 *)sys_buf + tail_ptr_wrap,  part_log)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e58532b1-90d0-4ff7-9cde-8297aaf4399c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/shim/umq/hwctx.cpp"
                },
                "region": {
                  "startLine": 42,
                  "startColumn": 7,
                  "endLine": 42,
                  "endColumn": 56,
                  "charOffset": 1162,
                  "charLength": 49,
                  "snippet": {
                    "text": "memcpy(m_log_buf, &m_metadata, sizeof(m_metadata)",
                    "rendered": {
                      "text": "memcpy(m_log_buf, &m_metadata, sizeof(m_metadata)",
                      "markdown": "`memcpy(m_log_buf, &m_metadata, sizeof(m_metadata)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/umq/hwctx.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1162,
                        "charLength": 49
                      },
                      "insertedContent": {
                        "text": "memcpy_s(m_log_buf, <size of m_log_buf>,  &m_metadata,  sizeof(m_metadata)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-ad3b405a-ca2e-453e-9319-881fa4143c5c",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/shim/kmq/hwctx.cpp"
                },
                "region": {
                  "startLine": 45,
                  "startColumn": 9,
                  "endLine": 45,
                  "endColumn": 49,
                  "charOffset": 1314,
                  "charLength": 40,
                  "snippet": {
                    "text": "memcpy(pdi_vaddr, pdi.data(), pdi.size()",
                    "rendered": {
                      "text": "memcpy(pdi_vaddr, pdi.data(), pdi.size()",
                      "markdown": "`memcpy(pdi_vaddr, pdi.data(), pdi.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/kmq/hwctx.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 1314,
                        "charLength": 40
                      },
                      "insertedContent": {
                        "text": "memcpy_s(pdi_vaddr, <size of pdi_vaddr>,  pdi.data(),  pdi.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-77f1cec0-f210-4f76-9e89-bf0057125cee",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/amdxdna_sysfs.c"
                },
                "region": {
                  "startLine": 28,
                  "startColumn": 8,
                  "endLine": 28,
                  "endColumn": 15,
                  "charOffset": 776,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c33143c6-df85-446d-8d9e-7bdc696a9806",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/amdxdna_sysfs.c"
                },
                "region": {
                  "startLine": 20,
                  "startColumn": 8,
                  "endLine": 20,
                  "endColumn": 15,
                  "charOffset": 532,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e8eb877a-517a-41f9-b352-3429a722831c",
          "kind": "fail",
          "level": "warning",
          "message": {
            "text": "Banned C function detected"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/amdxdna_sysfs.c"
                },
                "region": {
                  "startLine": 12,
                  "startColumn": 8,
                  "endLine": 12,
                  "endColumn": 15,
                  "charOffset": 301,
                  "charLength": 7,
                  "snippet": {
                    "text": "sprintf",
                    "rendered": {
                      "text": "sprintf",
                      "markdown": "`sprintf`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "properties": {
            "DevSkimSeverity": "Moderate",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-669eb18f-5271-4501-ab14-72188cd20441",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_psp.c"
                },
                "region": {
                  "startLine": 146,
                  "startColumn": 1,
                  "endLine": 146,
                  "endColumn": 61,
                  "charOffset": 3346,
                  "charLength": 60,
                  "snippet": {
                    "text": "memcpy(psp->fw_buffer + offset, conf->fw_buf, conf->fw_size)",
                    "rendered": {
                      "text": "memcpy(psp->fw_buffer + offset, conf->fw_buf, conf->fw_size)",
                      "markdown": "`memcpy(psp->fw_buffer + offset, conf->fw_buf, conf->fw_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3346,
                        "charLength": 60
                      },
                      "insertedContent": {
                        "text": "memcpy_s(psp->fw_buffer + offset, <size of psp->fw_buffer + offset>,  conf->fw_buf,  conf->fw_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0904a6bb-a601-42af-a866-2c7883a1b0d9",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_psp.c"
                },
                "region": {
                  "startLine": 134,
                  "startColumn": 1,
                  "endLine": 134,
                  "endColumn": 60,
                  "charOffset": 2917,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(psp->psp_regs, conf->psp_regs, sizeof(psp->psp_regs)",
                    "rendered": {
                      "text": "memcpy(psp->psp_regs, conf->psp_regs, sizeof(psp->psp_regs)",
                      "markdown": "`memcpy(psp->psp_regs, conf->psp_regs, sizeof(psp->psp_regs)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_psp.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 2917,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(psp->psp_regs, <size of psp->psp_regs>,  conf->psp_regs,  sizeof(psp->psp_regs)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-58676fef-2f89-4114-add4-ed2cd92d80e5",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_debugfs.c"
                },
                "region": {
                  "startLine": 191,
                  "startColumn": 38,
                  "endLine": 191,
                  "endColumn": 54,
                  "charOffset": 4659,
                  "charLength": 16,
                  "snippet": {
                    "text": "strlen(\"resume\")",
                    "rendered": {
                      "text": "strlen(\"resume\")",
                      "markdown": "`strlen(\"resume\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4659,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"resume\", <size of \"resume\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4659,
                        "charLength": 16
                      },
                      "insertedContent": {
                        "text": "strnlen(\"resume\", <size of \"resume\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-cb969754-66d0-4ee1-8289-9ac7d8028596",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/shim/device.cpp"
                },
                "region": {
                  "startLine": 746,
                  "startColumn": 4,
                  "endLine": 746,
                  "endColumn": 60,
                  "charOffset": 24237,
                  "charLength": 56,
                  "snippet": {
                    "text": "memcpy(data->m_clock_freq, clocks.data(), (clocks.size()",
                    "rendered": {
                      "text": "memcpy(data->m_clock_freq, clocks.data(), (clocks.size()",
                      "markdown": "`memcpy(data->m_clock_freq, clocks.data(), (clocks.size()`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/device.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 24237,
                        "charLength": 56
                      },
                      "insertedContent": {
                        "text": "memcpy_s(data->m_clock_freq, <size of data->m_clock_freq>,  clocks.data(),  (clocks.size()"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-5b76936a-58aa-4767-b5f3-d3bd3b5c5043",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_debugfs.c"
                },
                "region": {
                  "startLine": 187,
                  "startColumn": 32,
                  "endLine": 187,
                  "endColumn": 49,
                  "charOffset": 4502,
                  "charLength": 17,
                  "snippet": {
                    "text": "strlen(\"suspend\")",
                    "rendered": {
                      "text": "strlen(\"suspend\")",
                      "markdown": "`strlen(\"suspend\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4502,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"suspend\", <size of \"suspend\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 4502,
                        "charLength": 17
                      },
                      "insertedContent": {
                        "text": "strnlen(\"suspend\", <size of \"suspend\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-4cdba605-8915-4e31-9acc-51fc99e127fe",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/shim/device.cpp"
                },
                "region": {
                  "startLine": 738,
                  "startColumn": 4,
                  "endLine": 738,
                  "endColumn": 85,
                  "charOffset": 23819,
                  "charLength": 81,
                  "snippet": {
                    "text": "strcpy(h_clock.m_name, reinterpret_cast<const char*>(clock_metadata.h_clock.name)",
                    "rendered": {
                      "text": "strcpy(h_clock.m_name, reinterpret_cast<const char*>(clock_metadata.h_clock.name)",
                      "markdown": "`strcpy(h_clock.m_name, reinterpret_cast<const char*>(clock_metadata.h_clock.name)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/device.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23819,
                        "charLength": 81
                      },
                      "insertedContent": {
                        "text": "strcpy_s(h_clock.m_name, <size of h_clock.m_name>,  reinterpret_cast<const char*>(clock_metadata.h_clock.name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/device.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23819,
                        "charLength": 81
                      },
                      "insertedContent": {
                        "text": "strlcpy(h_clock.m_name,  reinterpret_cast<const char*>(clock_metadata.h_clock.name, <size of h_clock.m_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-e543b0d8-26ae-4159-b497-24547c384302",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_debugfs.c"
                },
                "region": {
                  "startLine": 128,
                  "startColumn": 35,
                  "endLine": 128,
                  "endColumn": 48,
                  "charOffset": 3251,
                  "charLength": 13,
                  "snippet": {
                    "text": "strlen(\"off\")",
                    "rendered": {
                      "text": "strlen(\"off\")",
                      "markdown": "`strlen(\"off\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3251,
                        "charLength": 13
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"off\", <size of \"off\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3251,
                        "charLength": 13
                      },
                      "insertedContent": {
                        "text": "strnlen(\"off\", <size of \"off\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-a6342fa8-cc35-49b6-9b81-34e2ec5ca7e7",
          "kind": "fail",
          "level": "error",
          "message": {
            "text": "Banned C function detected (strcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/shim/device.cpp"
                },
                "region": {
                  "startLine": 732,
                  "startColumn": 4,
                  "endLine": 732,
                  "endColumn": 95,
                  "charOffset": 23555,
                  "charLength": 91,
                  "snippet": {
                    "text": "strcpy(mp_npu_clock.m_name, reinterpret_cast<const char*>(clock_metadata.mp_npu_clock.name)",
                    "rendered": {
                      "text": "strcpy(mp_npu_clock.m_name, reinterpret_cast<const char*>(clock_metadata.mp_npu_clock.name)",
                      "markdown": "`strcpy(mp_npu_clock.m_name, reinterpret_cast<const char*>(clock_metadata.mp_npu_clock.name)`"
                    }
                  },
                  "sourceLanguage": "cpp"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/device.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23555,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "strcpy_s(mp_npu_clock.m_name, <size of mp_npu_clock.m_name>,  reinterpret_cast<const char*>(clock_metadata.mp_npu_clock.name)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "strcpy is frequently dangerous, as it will cause a buffer overflow if the source is larger than the destination."
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/shim/device.cpp"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 23555,
                        "charLength": 91
                      },
                      "insertedContent": {
                        "text": "strlcpy(mp_npu_clock.m_name,  reinterpret_cast<const char*>(clock_metadata.mp_npu_clock.name, <size of mp_npu_clock.m_name>)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "Important",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.BannedFunction"
            ]
          }
        },
        {
          "ruleId": "glog-6850c250-82ce-4a65-8929-b35ea8c28021",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (strlen)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/aie2_debugfs.c"
                },
                "region": {
                  "startLine": 126,
                  "startColumn": 27,
                  "endLine": 126,
                  "endColumn": 39,
                  "charOffset": 3162,
                  "charLength": 12,
                  "snippet": {
                    "text": "strlen(\"on\")",
                    "rendered": {
                      "text": "strlen(\"on\")",
                      "markdown": "`strlen(\"on\")`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3162,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strlen_s(\"on\", <size of \"on\">)"
                      }
                    }
                  ]
                }
              ]
            },
            {
              "description": {
                "text": "If a string is missing a null terminator, strlen will read past the end of the buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/aie2_debugfs.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 3162,
                        "charLength": 12
                      },
                      "insertedContent": {
                        "text": "strnlen(\"on\", <size of \"on\">)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-775bfa79-b80b-4074-aa93-56cf383929fa",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/amdxdna_mailbox.c"
                },
                "region": {
                  "startLine": 1004,
                  "startColumn": 1,
                  "endLine": 1004,
                  "endColumn": 35,
                  "charOffset": 25628,
                  "charLength": 34,
                  "snippet": {
                    "text": "memcpy(&mb->res, res, sizeof(*res)",
                    "rendered": {
                      "text": "memcpy(&mb->res, res, sizeof(*res)",
                      "markdown": "`memcpy(&mb->res, res, sizeof(*res)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/amdxdna_mailbox.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 25628,
                        "charLength": 34
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&mb->res, <size of &mb->res>,  res,  sizeof(*res)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-f91ab641-12af-4db9-baa5-4bf0ab5cc3e6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/amdxdna_mailbox.c"
                },
                "region": {
                  "startLine": 863,
                  "startColumn": 1,
                  "endLine": 863,
                  "endColumn": 55,
                  "charOffset": 22084,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(&mb_chann->res[CHAN_RES_I2X], i2x, sizeof(*i2x)",
                    "rendered": {
                      "text": "memcpy(&mb_chann->res[CHAN_RES_I2X], i2x, sizeof(*i2x)",
                      "markdown": "`memcpy(&mb_chann->res[CHAN_RES_I2X], i2x, sizeof(*i2x)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/amdxdna_mailbox.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 22084,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&mb_chann->res[CHAN_RES_I2X], <size of &mb_chann->res[CHAN_RES_I2X]>,  i2x,  sizeof(*i2x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-c52064ef-d2e7-48f3-8f9c-5fef383af703",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/amdxdna_mailbox.c"
                },
                "region": {
                  "startLine": 862,
                  "startColumn": 1,
                  "endLine": 862,
                  "endColumn": 55,
                  "charOffset": 22026,
                  "charLength": 54,
                  "snippet": {
                    "text": "memcpy(&mb_chann->res[CHAN_RES_X2I], x2i, sizeof(*x2i)",
                    "rendered": {
                      "text": "memcpy(&mb_chann->res[CHAN_RES_X2I], x2i, sizeof(*x2i)",
                      "markdown": "`memcpy(&mb_chann->res[CHAN_RES_X2I], x2i, sizeof(*x2i)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/amdxdna_mailbox.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 22026,
                        "charLength": 54
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&mb_chann->res[CHAN_RES_X2I], <size of &mb_chann->res[CHAN_RES_X2I]>,  x2i,  sizeof(*x2i)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-0272532d-5f4a-4bf1-82b8-2c6215035c9e",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/amdxdna_mailbox.c"
                },
                "region": {
                  "startLine": 745,
                  "startColumn": 1,
                  "endLine": 745,
                  "endColumn": 42,
                  "charOffset": 18639,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(&record->re_i2x, i2x, sizeof(*i2x)",
                    "rendered": {
                      "text": "memcpy(&record->re_i2x, i2x, sizeof(*i2x)",
                      "markdown": "`memcpy(&record->re_i2x, i2x, sizeof(*i2x)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/amdxdna_mailbox.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18639,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&record->re_i2x, <size of &record->re_i2x>,  i2x,  sizeof(*i2x)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-7085d05b-0ea4-42f0-b60d-0a690e45dce6",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/amdxdna_mailbox.c"
                },
                "region": {
                  "startLine": 744,
                  "startColumn": 1,
                  "endLine": 744,
                  "endColumn": 42,
                  "charOffset": 18594,
                  "charLength": 41,
                  "snippet": {
                    "text": "memcpy(&record->re_x2i, x2i, sizeof(*x2i)",
                    "rendered": {
                      "text": "memcpy(&record->re_x2i, x2i, sizeof(*x2i)",
                      "markdown": "`memcpy(&record->re_x2i, x2i, sizeof(*x2i)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/amdxdna_mailbox.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 18594,
                        "charLength": 41
                      },
                      "insertedContent": {
                        "text": "memcpy_s(&record->re_x2i, <size of &record->re_x2i>,  x2i,  sizeof(*x2i)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        },
        {
          "ruleId": "glog-721bb065-0c59-404e-8e37-48f76a76cb26",
          "kind": "fail",
          "level": "note",
          "message": {
            "text": "Problematic C function detected (memcpy)"
          },
          "locations": [
            {
              "physicalLocation": {
                "artifactLocation": {
                  "uri": "src/driver/amdxdna/amdxdna_mailbox.c"
                },
                "region": {
                  "startLine": 678,
                  "startColumn": 1,
                  "endLine": 678,
                  "endColumn": 60,
                  "charOffset": 17073,
                  "charLength": 59,
                  "snippet": {
                    "text": "memcpy(mb_msg->pkg.payload, msg->send_data, msg->send_size)",
                    "rendered": {
                      "text": "memcpy(mb_msg->pkg.payload, msg->send_data, msg->send_size)",
                      "markdown": "`memcpy(mb_msg->pkg.payload, msg->send_data, msg->send_size)`"
                    }
                  },
                  "sourceLanguage": "c"
                }
              }
            }
          ],
          "fixes": [
            {
              "description": {
                "text": "There are a number of conditions in which memcpy can introduce a vulnerability (mismatched buffer sizes, null pointers, etc.). More secure alternitives perform additional validation of the source and destination buffer"
              },
              "artifactChanges": [
                {
                  "artifactLocation": {
                    "uri": "src/driver/amdxdna/amdxdna_mailbox.c"
                  },
                  "replacements": [
                    {
                      "deletedRegion": {
                        "charOffset": 17073,
                        "charLength": 59
                      },
                      "insertedContent": {
                        "text": "memcpy_s(mb_msg->pkg.payload, <size of mb_msg->pkg.payload>,  msg->send_data,  msg->send_size)"
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "properties": {
            "DevSkimSeverity": "BestPractice",
            "DevSkimConfidence": "High",
            "tags": [
              "API.DangerousAPI.ProblematicFunction"
            ]
          }
        }
      ],
      "newlineSequences": [
        "\r\n",
        "\n"
      ]
    }
  ]
}